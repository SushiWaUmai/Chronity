{
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Refernce | Chronity",
    "keywords": "Chronity API Reference This is the API Reference of the Chronity Package. Get started with the Chronity namespace."
  },
  "index.html": {
    "href": "index.html",
    "title": "A Unity3D Timer Library | Chronity",
    "keywords": ""
  },
  "manual/features.html": {
    "href": "manual/features.html",
    "title": "Features | Chronity",
    "keywords": "Features âœ¨ Make a timer repeat by setting isLooped to true. // Log \"Hello World\" every 10 seconds. Timer.Register(10f, () => Debug.Log(\"Hello World\"), isLooped: true); Cancel a timer after calling it. private Timer timer; private void Start() { timer = Timer.Register(2f, () => Debug.Log(\"You won't see this text if you press X.\")); } private void Update() { if (Input.GetKeyDown(KeyCode.X)) { Timer.Cancel(timer); } } Attach the timer to a MonoBehaviour so that the timer is destroyed when the MonoBehaviour is. Very often, a timer called from a MonoBehaviour will manipulate that behaviour's state. Thus, it is common practice to cancel the timer in the OnDestroy method of the MonoBehaviour. We've added a convenient extension method that attaches a Timer to a MonoBehaviour such that it will automatically cancel the timer when the MonoBehaviour is detected as null. public class CoolMonoBehaviour : MonoBehaviour { private void Start() { // Use the AttachTimer extension method to create a timer that is destroyed when this // object is destroyed. this.RegisterTimer(5f, () => { // If this code runs after the object is destroyed, a null reference will be thrown, // which could corrupt game state. this.gameObject.transform.position = Vector3.zero; }); } private void Update() { // This code could destroy the object at any time! if (Input.GetKeyDown(KeyCode.X)) { GameObject.Destroy(this.gameObject); } } } Update a value gradually over time using the onUpdate callback. // Change a color from white to red over the course of five seconds. Color color = Color.white; float transitionDuration = 5f; Timer.Register(transitionDuration, onUpdate: secondsElapsed => color.r = 255 * (secondsElapsed / transitionDuration), onComplete: () => Debug.Log(\"Color is now red\")); Make a timer run in the editor by using the EditorTimer class. // Logs \"Hello World\" after 5 seconds in the editor EditorTimer.Register(5, () => Debug.Log(\"Hello World\"));"
  },
  "manual/getting-started.html": {
    "href": "manual/getting-started.html",
    "title": "Getting Started | Chronity",
    "keywords": "Getting Started ðŸš€ Installation Install with Git Please follow the instructions in the manual about Installing a package from a Git URL . Use the following URL to install the latest version of the package: https://github.com/SushiWaUmai/Chronity.git?path=/com.sushiwaumai.chronity Install with OpenUPM This needs OpenUPM to be installed to your machine. Chronity can also be installed using OpenUPM. Run the following command on the project root folder: openupm add com.sushiwaumai.chronity Quick Start ðŸŽ“ This is how to call a function after a delay in Chronity. // Log \"Hello World\" after five seconds. Timer.Register(5f, () => Debug.Log(\"Hello World\"));"
  }
}